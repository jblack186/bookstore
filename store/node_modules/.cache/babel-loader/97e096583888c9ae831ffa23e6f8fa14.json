{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar _diffSequences = _interopRequireDefault(require('diff-sequences'));\n\nvar _constants = require('./constants');\n\nvar _printDiffs = require('./printDiffs');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst DIFF_CONTEXT_DEFAULT = 5;\nconst fgDelete = _chalk.default.green;\nconst fgInsert = _chalk.default.red;\nconst fgCommon = _chalk.default.dim; // common lines (even indentation same)\n\nconst fgIndent = _chalk.default.cyan; // common lines (only indentation different)\n\nconst bgCommon = _chalk.default.bgYellow; // edge spaces in common line (even indentation same)\n\nconst bgInverse = _chalk.default.inverse; // edge spaces in any other lines\n// ONLY trailing if expected value is snapshot or multiline string.\n\nconst highlightTrailingSpaces = (line, bgColor) => line.replace(/\\s+$/, bgColor('$&')); // BOTH leading AND trailing if expected value is data structure.\n\n\nconst highlightLeadingTrailingSpaces = (line, bgColor // If line consists of ALL spaces: highlight all of them.\n) => highlightTrailingSpaces(line, bgColor).replace( // If line has an ODD length of leading spaces: highlight only the LAST.\n/^(\\s\\s)*(\\s)(?=[^\\s])/, '$1' + bgColor('$2'));\n\nconst getHighlightSpaces = bothEdges => bothEdges ? highlightLeadingTrailingSpaces : highlightTrailingSpaces; // Given index interval in expected lines, put formatted delete lines.\n\n\nconst formatDelete = (aStart, aEnd, aLinesUn, aLinesIn, put) => {\n  const highlightSpaces = getHighlightSpaces(aLinesUn !== aLinesIn);\n\n  for (let aIndex = aStart; aIndex !== aEnd; aIndex += 1) {\n    const aLineUn = aLinesUn[aIndex];\n    const aLineIn = aLinesIn[aIndex];\n    const indentation = aLineIn.slice(0, aLineIn.length - aLineUn.length);\n    put(fgDelete('- ' + indentation + highlightSpaces(aLineUn, bgInverse)));\n  }\n}; // Given index interval in received lines, put formatted insert lines.\n\n\nconst formatInsert = (bStart, bEnd, bLinesUn, bLinesIn, put) => {\n  const highlightSpaces = getHighlightSpaces(bLinesUn !== bLinesIn);\n\n  for (let bIndex = bStart; bIndex !== bEnd; bIndex += 1) {\n    const bLineUn = bLinesUn[bIndex];\n    const bLineIn = bLinesIn[bIndex];\n    const indentation = bLineIn.slice(0, bLineIn.length - bLineUn.length);\n    put(fgInsert('+ ' + indentation + highlightSpaces(bLineUn, bgInverse)));\n  }\n}; // Given the number of items and starting indexes of a common subsequence,\n// put formatted common lines.\n\n\nconst formatCommon = (nCommon, aCommon, bCommon, aLinesIn, bLinesUn, bLinesIn, put) => {\n  const highlightSpaces = getHighlightSpaces(bLinesUn !== bLinesIn);\n\n  for (; nCommon !== 0; nCommon -= 1, aCommon += 1, bCommon += 1) {\n    const bLineUn = bLinesUn[bCommon];\n    const bLineIn = bLinesIn[bCommon];\n    const bLineInLength = bLineIn.length; // For common lines, received indentation seems more intuitive.\n\n    const indentation = bLineIn.slice(0, bLineInLength - bLineUn.length); // Color shows whether expected and received line has same indentation.\n\n    const hasSameIndentation = aLinesIn[aCommon].length === bLineInLength;\n    const fg = hasSameIndentation ? fgCommon : fgIndent;\n    const bg = hasSameIndentation ? bgCommon : bgInverse;\n    put(fg('  ' + indentation + highlightSpaces(bLineUn, bg)));\n  }\n}; // jest --expand\n// Return formatted diff as joined string of all lines.\n\n\nconst diffExpand = (aLinesUn, bLinesUn, aLinesIn, bLinesIn) => {\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  const array = [];\n\n  const put = line => {\n    array.push(line);\n  };\n\n  let aStart = 0;\n  let bStart = 0;\n\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    formatDelete(aStart, aCommon, aLinesUn, aLinesIn, put);\n    formatInsert(bStart, bCommon, bLinesUn, bLinesIn, put);\n    formatCommon(nCommon, aCommon, bCommon, aLinesIn, bLinesUn, bLinesIn, put);\n    aStart = aCommon + nCommon;\n    bStart = bCommon + nCommon;\n  };\n\n  const aLength = aLinesUn.length;\n  const bLength = bLinesUn.length;\n  (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence); // After the last common subsequence, format remaining change lines.\n\n  formatDelete(aStart, aLength, aLinesUn, aLinesIn, put);\n  formatInsert(bStart, bLength, bLinesUn, bLinesIn, put);\n  return array.join('\\n');\n};\n\nconst getContextLines = options => options && typeof options.contextLines === 'number' && options.contextLines >= 0 ? options.contextLines : DIFF_CONTEXT_DEFAULT; // jest --no-expand\n// Return joined string of formatted diff for all change lines,\n// but if some common lines are omitted because there are more than the context,\n// then a “patch mark” precedes each set of adjacent changed and common lines.\n\n\nconst diffNoExpand = (aLinesUn, bLinesUn, aLinesIn, bLinesIn, nContextLines) => {\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  let iPatchMark = 0; // index of placeholder line for patch mark\n\n  const array = [''];\n\n  const put = line => {\n    array.push(line);\n  };\n\n  let isAtEnd = false;\n  const aLength = aLinesUn.length;\n  const bLength = bLinesUn.length;\n  const nContextLines2 = nContextLines + nContextLines; // Initialize the first patch for changes at the start,\n  // especially for edge case in which there is no common subsequence.\n\n  let aStart = 0;\n  let aEnd = 0;\n  let bStart = 0;\n  let bEnd = 0; // Given the number of items and starting indexes of each common subsequence,\n  // format any preceding change lines, and then common context lines.\n\n  const foundSubsequence = (nCommon, aStartCommon, bStartCommon) => {\n    const aEndCommon = aStartCommon + nCommon;\n    const bEndCommon = bStartCommon + nCommon;\n    isAtEnd = aEndCommon === aLength && bEndCommon === bLength; // If common subsequence is at start, re-initialize the first patch.\n\n    if (aStartCommon === 0 && bStartCommon === 0) {\n      const nLines = nContextLines < nCommon ? nContextLines : nCommon;\n      aStart = aEndCommon - nLines;\n      bStart = bEndCommon - nLines;\n      formatCommon(nLines, aStart, bStart, aLinesIn, bLinesUn, bLinesIn, put);\n      aEnd = aEndCommon;\n      bEnd = bEndCommon;\n      return;\n    } // Format preceding change lines.\n\n\n    formatDelete(aEnd, aStartCommon, aLinesUn, aLinesIn, put);\n    formatInsert(bEnd, bStartCommon, bLinesUn, bLinesIn, put);\n    aEnd = aStartCommon;\n    bEnd = bStartCommon; // If common subsequence is at end, then context follows preceding changes;\n    // else context follows preceding changes AND precedes following changes.\n\n    const maxContextLines = isAtEnd ? nContextLines : nContextLines2;\n\n    if (nCommon <= maxContextLines) {\n      // The patch includes all lines in the common subsequence.\n      formatCommon(nCommon, aEnd, bEnd, aLinesIn, bLinesUn, bLinesIn, put);\n      aEnd += nCommon;\n      bEnd += nCommon;\n      return;\n    } // The patch ends because context is less than number of common lines.\n\n\n    formatCommon(nContextLines, aEnd, bEnd, aLinesIn, bLinesUn, bLinesIn, put);\n    aEnd += nContextLines;\n    bEnd += nContextLines;\n    array[iPatchMark] = (0, _printDiffs.createPatchMark)(aStart, aEnd, bStart, bEnd); // If common subsequence is not at end, another patch follows it.\n\n    if (!isAtEnd) {\n      iPatchMark = array.length; // index of placeholder line\n\n      array[iPatchMark] = '';\n      const nLines = nContextLines < nCommon ? nContextLines : nCommon;\n      aStart = aEndCommon - nLines;\n      bStart = bEndCommon - nLines;\n      formatCommon(nLines, aStart, bStart, aLinesIn, bLinesUn, bLinesIn, put);\n      aEnd = aEndCommon;\n      bEnd = bEndCommon;\n    }\n  };\n\n  (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence); // If no common subsequence or last was not at end, format remaining change lines.\n\n  if (!isAtEnd) {\n    formatDelete(aEnd, aLength, aLinesUn, aLinesIn, put);\n    formatInsert(bEnd, bLength, bLinesUn, bLinesIn, put);\n    aEnd = aLength;\n    bEnd = bLength;\n  }\n\n  if (aStart === 0 && aEnd === aLength && bStart === 0 && bEnd === bLength) {\n    array.splice(0, 1); // delete placeholder line for patch mark\n  } else {\n    array[iPatchMark] = (0, _printDiffs.createPatchMark)(aStart, aEnd, bStart, bEnd);\n  }\n\n  return array.join('\\n');\n};\n\nvar _default = (a, b, options, original) => {\n  if (a === b) {\n    return _constants.NO_DIFF_MESSAGE;\n  }\n\n  let aLinesUn = a.split('\\n');\n  let bLinesUn = b.split('\\n'); // Indentation is unknown if expected value is snapshot or multiline string.\n\n  let aLinesIn = aLinesUn;\n  let bLinesIn = bLinesUn;\n\n  if (original) {\n    // Indentation is known if expected value is data structure:\n    // Compare lines without indentation and format lines with indentation.\n    aLinesIn = original.a.split('\\n');\n    bLinesIn = original.b.split('\\n');\n\n    if (aLinesUn.length !== aLinesIn.length || bLinesUn.length !== bLinesIn.length) {\n      // Fall back if unindented and indented lines are inconsistent.\n      aLinesUn = aLinesIn;\n      bLinesUn = bLinesIn;\n    }\n  }\n\n  return (0, _printDiffs.printAnnotation)(options) + (options && options.expand === false ? diffNoExpand(aLinesUn, bLinesUn, aLinesIn, bLinesIn, getContextLines(options)) : diffExpand(aLinesUn, bLinesUn, aLinesIn, bLinesIn));\n};\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/jamie/Documents/bookstore/store/node_modules/jest-diff/build/diffLines.js"],"names":["Object","defineProperty","exports","value","default","_chalk","_interopRequireDefault","require","_diffSequences","_constants","_printDiffs","obj","__esModule","DIFF_CONTEXT_DEFAULT","fgDelete","green","fgInsert","red","fgCommon","dim","fgIndent","cyan","bgCommon","bgYellow","bgInverse","inverse","highlightTrailingSpaces","line","bgColor","replace","highlightLeadingTrailingSpaces","getHighlightSpaces","bothEdges","formatDelete","aStart","aEnd","aLinesUn","aLinesIn","put","highlightSpaces","aIndex","aLineUn","aLineIn","indentation","slice","length","formatInsert","bStart","bEnd","bLinesUn","bLinesIn","bIndex","bLineUn","bLineIn","formatCommon","nCommon","aCommon","bCommon","bLineInLength","hasSameIndentation","fg","bg","diffExpand","isCommon","array","push","foundSubsequence","aLength","bLength","join","getContextLines","options","contextLines","diffNoExpand","nContextLines","iPatchMark","isAtEnd","nContextLines2","aStartCommon","bStartCommon","aEndCommon","bEndCommon","nLines","maxContextLines","createPatchMark","splice","_default","a","b","original","NO_DIFF_MESSAGE","split","printAnnotation","expand"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar _diffSequences = _interopRequireDefault(require('diff-sequences'));\n\nvar _constants = require('./constants');\n\nvar _printDiffs = require('./printDiffs');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst DIFF_CONTEXT_DEFAULT = 5;\nconst fgDelete = _chalk.default.green;\nconst fgInsert = _chalk.default.red;\nconst fgCommon = _chalk.default.dim; // common lines (even indentation same)\n\nconst fgIndent = _chalk.default.cyan; // common lines (only indentation different)\n\nconst bgCommon = _chalk.default.bgYellow; // edge spaces in common line (even indentation same)\n\nconst bgInverse = _chalk.default.inverse; // edge spaces in any other lines\n// ONLY trailing if expected value is snapshot or multiline string.\n\nconst highlightTrailingSpaces = (line, bgColor) =>\n  line.replace(/\\s+$/, bgColor('$&')); // BOTH leading AND trailing if expected value is data structure.\n\nconst highlightLeadingTrailingSpaces = (\n  line,\n  bgColor // If line consists of ALL spaces: highlight all of them.\n) =>\n  highlightTrailingSpaces(line, bgColor).replace(\n    // If line has an ODD length of leading spaces: highlight only the LAST.\n    /^(\\s\\s)*(\\s)(?=[^\\s])/,\n    '$1' + bgColor('$2')\n  );\n\nconst getHighlightSpaces = bothEdges =>\n  bothEdges ? highlightLeadingTrailingSpaces : highlightTrailingSpaces;\n\n// Given index interval in expected lines, put formatted delete lines.\nconst formatDelete = (aStart, aEnd, aLinesUn, aLinesIn, put) => {\n  const highlightSpaces = getHighlightSpaces(aLinesUn !== aLinesIn);\n\n  for (let aIndex = aStart; aIndex !== aEnd; aIndex += 1) {\n    const aLineUn = aLinesUn[aIndex];\n    const aLineIn = aLinesIn[aIndex];\n    const indentation = aLineIn.slice(0, aLineIn.length - aLineUn.length);\n    put(fgDelete('- ' + indentation + highlightSpaces(aLineUn, bgInverse)));\n  }\n}; // Given index interval in received lines, put formatted insert lines.\n\nconst formatInsert = (bStart, bEnd, bLinesUn, bLinesIn, put) => {\n  const highlightSpaces = getHighlightSpaces(bLinesUn !== bLinesIn);\n\n  for (let bIndex = bStart; bIndex !== bEnd; bIndex += 1) {\n    const bLineUn = bLinesUn[bIndex];\n    const bLineIn = bLinesIn[bIndex];\n    const indentation = bLineIn.slice(0, bLineIn.length - bLineUn.length);\n    put(fgInsert('+ ' + indentation + highlightSpaces(bLineUn, bgInverse)));\n  }\n}; // Given the number of items and starting indexes of a common subsequence,\n// put formatted common lines.\n\nconst formatCommon = (\n  nCommon,\n  aCommon,\n  bCommon,\n  aLinesIn,\n  bLinesUn,\n  bLinesIn,\n  put\n) => {\n  const highlightSpaces = getHighlightSpaces(bLinesUn !== bLinesIn);\n\n  for (; nCommon !== 0; nCommon -= 1, aCommon += 1, bCommon += 1) {\n    const bLineUn = bLinesUn[bCommon];\n    const bLineIn = bLinesIn[bCommon];\n    const bLineInLength = bLineIn.length; // For common lines, received indentation seems more intuitive.\n\n    const indentation = bLineIn.slice(0, bLineInLength - bLineUn.length); // Color shows whether expected and received line has same indentation.\n\n    const hasSameIndentation = aLinesIn[aCommon].length === bLineInLength;\n    const fg = hasSameIndentation ? fgCommon : fgIndent;\n    const bg = hasSameIndentation ? bgCommon : bgInverse;\n    put(fg('  ' + indentation + highlightSpaces(bLineUn, bg)));\n  }\n}; // jest --expand\n// Return formatted diff as joined string of all lines.\n\nconst diffExpand = (aLinesUn, bLinesUn, aLinesIn, bLinesIn) => {\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  const array = [];\n\n  const put = line => {\n    array.push(line);\n  };\n\n  let aStart = 0;\n  let bStart = 0;\n\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    formatDelete(aStart, aCommon, aLinesUn, aLinesIn, put);\n    formatInsert(bStart, bCommon, bLinesUn, bLinesIn, put);\n    formatCommon(nCommon, aCommon, bCommon, aLinesIn, bLinesUn, bLinesIn, put);\n    aStart = aCommon + nCommon;\n    bStart = bCommon + nCommon;\n  };\n\n  const aLength = aLinesUn.length;\n  const bLength = bLinesUn.length;\n  (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence); // After the last common subsequence, format remaining change lines.\n\n  formatDelete(aStart, aLength, aLinesUn, aLinesIn, put);\n  formatInsert(bStart, bLength, bLinesUn, bLinesIn, put);\n  return array.join('\\n');\n};\n\nconst getContextLines = options =>\n  options &&\n  typeof options.contextLines === 'number' &&\n  options.contextLines >= 0\n    ? options.contextLines\n    : DIFF_CONTEXT_DEFAULT; // jest --no-expand\n// Return joined string of formatted diff for all change lines,\n// but if some common lines are omitted because there are more than the context,\n// then a “patch mark” precedes each set of adjacent changed and common lines.\n\nconst diffNoExpand = (\n  aLinesUn,\n  bLinesUn,\n  aLinesIn,\n  bLinesIn,\n  nContextLines\n) => {\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  let iPatchMark = 0; // index of placeholder line for patch mark\n\n  const array = [''];\n\n  const put = line => {\n    array.push(line);\n  };\n\n  let isAtEnd = false;\n  const aLength = aLinesUn.length;\n  const bLength = bLinesUn.length;\n  const nContextLines2 = nContextLines + nContextLines; // Initialize the first patch for changes at the start,\n  // especially for edge case in which there is no common subsequence.\n\n  let aStart = 0;\n  let aEnd = 0;\n  let bStart = 0;\n  let bEnd = 0; // Given the number of items and starting indexes of each common subsequence,\n  // format any preceding change lines, and then common context lines.\n\n  const foundSubsequence = (nCommon, aStartCommon, bStartCommon) => {\n    const aEndCommon = aStartCommon + nCommon;\n    const bEndCommon = bStartCommon + nCommon;\n    isAtEnd = aEndCommon === aLength && bEndCommon === bLength; // If common subsequence is at start, re-initialize the first patch.\n\n    if (aStartCommon === 0 && bStartCommon === 0) {\n      const nLines = nContextLines < nCommon ? nContextLines : nCommon;\n      aStart = aEndCommon - nLines;\n      bStart = bEndCommon - nLines;\n      formatCommon(nLines, aStart, bStart, aLinesIn, bLinesUn, bLinesIn, put);\n      aEnd = aEndCommon;\n      bEnd = bEndCommon;\n      return;\n    } // Format preceding change lines.\n\n    formatDelete(aEnd, aStartCommon, aLinesUn, aLinesIn, put);\n    formatInsert(bEnd, bStartCommon, bLinesUn, bLinesIn, put);\n    aEnd = aStartCommon;\n    bEnd = bStartCommon; // If common subsequence is at end, then context follows preceding changes;\n    // else context follows preceding changes AND precedes following changes.\n\n    const maxContextLines = isAtEnd ? nContextLines : nContextLines2;\n\n    if (nCommon <= maxContextLines) {\n      // The patch includes all lines in the common subsequence.\n      formatCommon(nCommon, aEnd, bEnd, aLinesIn, bLinesUn, bLinesIn, put);\n      aEnd += nCommon;\n      bEnd += nCommon;\n      return;\n    } // The patch ends because context is less than number of common lines.\n\n    formatCommon(nContextLines, aEnd, bEnd, aLinesIn, bLinesUn, bLinesIn, put);\n    aEnd += nContextLines;\n    bEnd += nContextLines;\n    array[iPatchMark] = (0, _printDiffs.createPatchMark)(\n      aStart,\n      aEnd,\n      bStart,\n      bEnd\n    ); // If common subsequence is not at end, another patch follows it.\n\n    if (!isAtEnd) {\n      iPatchMark = array.length; // index of placeholder line\n\n      array[iPatchMark] = '';\n      const nLines = nContextLines < nCommon ? nContextLines : nCommon;\n      aStart = aEndCommon - nLines;\n      bStart = bEndCommon - nLines;\n      formatCommon(nLines, aStart, bStart, aLinesIn, bLinesUn, bLinesIn, put);\n      aEnd = aEndCommon;\n      bEnd = bEndCommon;\n    }\n  };\n\n  (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence); // If no common subsequence or last was not at end, format remaining change lines.\n\n  if (!isAtEnd) {\n    formatDelete(aEnd, aLength, aLinesUn, aLinesIn, put);\n    formatInsert(bEnd, bLength, bLinesUn, bLinesIn, put);\n    aEnd = aLength;\n    bEnd = bLength;\n  }\n\n  if (aStart === 0 && aEnd === aLength && bStart === 0 && bEnd === bLength) {\n    array.splice(0, 1); // delete placeholder line for patch mark\n  } else {\n    array[iPatchMark] = (0, _printDiffs.createPatchMark)(\n      aStart,\n      aEnd,\n      bStart,\n      bEnd\n    );\n  }\n\n  return array.join('\\n');\n};\n\nvar _default = (a, b, options, original) => {\n  if (a === b) {\n    return _constants.NO_DIFF_MESSAGE;\n  }\n\n  let aLinesUn = a.split('\\n');\n  let bLinesUn = b.split('\\n'); // Indentation is unknown if expected value is snapshot or multiline string.\n\n  let aLinesIn = aLinesUn;\n  let bLinesIn = bLinesUn;\n\n  if (original) {\n    // Indentation is known if expected value is data structure:\n    // Compare lines without indentation and format lines with indentation.\n    aLinesIn = original.a.split('\\n');\n    bLinesIn = original.b.split('\\n');\n\n    if (\n      aLinesUn.length !== aLinesIn.length ||\n      bLinesUn.length !== bLinesIn.length\n    ) {\n      // Fall back if unindented and indented lines are inconsistent.\n      aLinesUn = aLinesIn;\n      bLinesUn = bLinesIn;\n    }\n  }\n\n  return (\n    (0, _printDiffs.printAnnotation)(options) +\n    (options && options.expand === false\n      ? diffNoExpand(\n          aLinesUn,\n          bLinesUn,\n          aLinesIn,\n          bLinesIn,\n          getContextLines(options)\n        )\n      : diffExpand(aLinesUn, bLinesUn, aLinesIn, bLinesIn))\n  );\n};\n\nexports.default = _default;\n"]},"metadata":{},"sourceType":"script"}