{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getStringDiff = exports.printMultilineStringDiffs = exports.createPatchMark = exports.printAnnotation = exports.hasCommonDiff = exports.computeStringDiffs = exports.printCommonLine = exports.printInsertLine = exports.printDeleteLine = exports.MULTILINE_REGEXP = exports.getReceivedString = exports.getExpectedString = exports.getHighlightedString = exports.RECEIVED_COLOR = exports.INVERTED_COLOR = exports.EXPECTED_COLOR = exports.DIM_COLOR = void 0;\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _diffStrings = _interopRequireDefault(require('./diffStrings'));\n\nvar _getAlignedDiffs = _interopRequireDefault(require('./getAlignedDiffs'));\n\nvar _joinAlignedDiffs = require('./joinAlignedDiffs');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst DIM_COLOR = _chalk.default.dim;\nexports.DIM_COLOR = DIM_COLOR;\nconst EXPECTED_COLOR = _chalk.default.green;\nexports.EXPECTED_COLOR = EXPECTED_COLOR;\nconst INVERTED_COLOR = _chalk.default.inverse;\nexports.INVERTED_COLOR = INVERTED_COLOR;\nconst RECEIVED_COLOR = _chalk.default.red;\nexports.RECEIVED_COLOR = RECEIVED_COLOR;\nconst PATCH_COLOR = _chalk.default.yellow; // Given change op and array of diffs, return concatenated string:\n// * include common strings\n// * include change strings which have argument op (inverse highlight)\n// * exclude change strings which have opposite op\n\nconst getHighlightedString = (op, diffs) => diffs.reduce((reduced, diff) => reduced + (diff[0] === _cleanupSemantic.DIFF_EQUAL ? diff[1] : diff[0] === op ? INVERTED_COLOR(diff[1]) : ''), '');\n\nexports.getHighlightedString = getHighlightedString;\n\nconst getExpectedString = diffs => getHighlightedString(_cleanupSemantic.DIFF_DELETE, diffs);\n\nexports.getExpectedString = getExpectedString;\n\nconst getReceivedString = diffs => getHighlightedString(_cleanupSemantic.DIFF_INSERT, diffs);\n\nexports.getReceivedString = getReceivedString;\nconst MULTILINE_REGEXP = /\\n/;\nexports.MULTILINE_REGEXP = MULTILINE_REGEXP;\nconst NEWLINE_SYMBOL = '\\u{21B5}'; // downwards arrow with corner leftwards\n\nconst SPACE_SYMBOL = '\\u{00B7}'; // middle dot\n// Instead of inverse highlight which now implies a change,\n// replace common spaces with middle dot at the end of the line.\n\nconst replaceSpacesAtEnd = line => line.replace(/\\s+$/, spaces => SPACE_SYMBOL.repeat(spaces.length));\n\nconst printDeleteLine = line => EXPECTED_COLOR(line.length !== 0 ? '- ' + replaceSpacesAtEnd(line) : '-');\n\nexports.printDeleteLine = printDeleteLine;\n\nconst printInsertLine = line => RECEIVED_COLOR(line.length !== 0 ? '+ ' + replaceSpacesAtEnd(line) : '+'); // Prevent visually ambiguous empty line as the first or the last.\n\n\nexports.printInsertLine = printInsertLine;\n\nconst printCommonLine = (line, isFirstOrLast = false) => line.length !== 0 ? DIM_COLOR('  ' + replaceSpacesAtEnd(line)) : isFirstOrLast ? DIM_COLOR('  ' + NEWLINE_SYMBOL) : '';\n\nexports.printCommonLine = printCommonLine;\n\nconst computeStringDiffs = (expected, received) => {\n  const isMultiline = MULTILINE_REGEXP.test(expected) || MULTILINE_REGEXP.test(received); // getAlignedDiffs assumes that a newline was appended to the strings.\n\n  if (isMultiline) {\n    expected += '\\n';\n    received += '\\n';\n  }\n\n  const diffs = (0, _diffStrings.default)(expected, received);\n  (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function\n\n  return {\n    diffs,\n    isMultiline\n  };\n};\n\nexports.computeStringDiffs = computeStringDiffs;\n\nconst hasCommonDiff = (diffs, isMultiline) => {\n  if (isMultiline) {\n    // Important: Ignore common newline that was appended to multiline strings!\n    const iLast = diffs.length - 1;\n    return diffs.some((diff, i) => diff[0] === _cleanupSemantic.DIFF_EQUAL && (i !== iLast || diff[1] !== '\\n'));\n  }\n\n  return diffs.some(diff => diff[0] === _cleanupSemantic.DIFF_EQUAL);\n};\n\nexports.hasCommonDiff = hasCommonDiff;\n\nconst printAnnotation = options => EXPECTED_COLOR('- ' + (options && options.aAnnotation || 'Expected')) + '\\n' + RECEIVED_COLOR('+ ' + (options && options.bAnnotation || 'Received')) + '\\n\\n'; // In GNU diff format, indexes are one-based instead of zero-based.\n\n\nexports.printAnnotation = printAnnotation;\n\nconst createPatchMark = (aStart, aEnd, bStart, bEnd) => PATCH_COLOR(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`); // Return formatted diff lines without labels.\n\n\nexports.createPatchMark = createPatchMark;\n\nconst printMultilineStringDiffs = (diffs, expand) => {\n  const lines = (0, _getAlignedDiffs.default)(diffs);\n  return expand ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(lines) : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(lines);\n};\n\nexports.printMultilineStringDiffs = printMultilineStringDiffs;\nconst MAX_DIFF_STRING_LENGTH = 20000; // Print specific substring diff for strings only:\n// * if strings are not equal\n// * if neither string is empty\n// * if neither string is too long\n// * if there is a common string after semantic cleanup\n\nconst getStringDiff = (expected, received, options) => {\n  if (expected === received || expected.length === 0 || received.length === 0 || expected.length > MAX_DIFF_STRING_LENGTH || received.length > MAX_DIFF_STRING_LENGTH) {\n    return null;\n  }\n\n  const _computeStringDiffs = computeStringDiffs(expected, received),\n        diffs = _computeStringDiffs.diffs,\n        isMultiline = _computeStringDiffs.isMultiline;\n\n  if (!hasCommonDiff(diffs, isMultiline)) {\n    return null;\n  }\n\n  return isMultiline ? {\n    annotatedDiff: printAnnotation(options) + printMultilineStringDiffs(diffs, options === undefined || options.expand !== false),\n    isMultiline\n  } : {\n    a: getExpectedString(diffs),\n    b: getReceivedString(diffs),\n    isMultiline\n  };\n};\n\nexports.getStringDiff = getStringDiff;","map":{"version":3,"sources":["/Users/jamie/Documents/bookstore/store/node_modules/jest-diff/build/printDiffs.js"],"names":["Object","defineProperty","exports","value","getStringDiff","printMultilineStringDiffs","createPatchMark","printAnnotation","hasCommonDiff","computeStringDiffs","printCommonLine","printInsertLine","printDeleteLine","MULTILINE_REGEXP","getReceivedString","getExpectedString","getHighlightedString","RECEIVED_COLOR","INVERTED_COLOR","EXPECTED_COLOR","DIM_COLOR","_chalk","_interopRequireDefault","require","_cleanupSemantic","_diffStrings","_getAlignedDiffs","_joinAlignedDiffs","obj","__esModule","default","dim","green","inverse","red","PATCH_COLOR","yellow","op","diffs","reduce","reduced","diff","DIFF_EQUAL","DIFF_DELETE","DIFF_INSERT","NEWLINE_SYMBOL","SPACE_SYMBOL","replaceSpacesAtEnd","line","replace","spaces","repeat","length","isFirstOrLast","expected","received","isMultiline","test","cleanupSemantic","iLast","some","i","options","aAnnotation","bAnnotation","aStart","aEnd","bStart","bEnd","expand","lines","joinAlignedDiffsExpand","joinAlignedDiffsNoExpand","MAX_DIFF_STRING_LENGTH","_computeStringDiffs","annotatedDiff","undefined","a","b"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getStringDiff = exports.printMultilineStringDiffs = exports.createPatchMark = exports.printAnnotation = exports.hasCommonDiff = exports.computeStringDiffs = exports.printCommonLine = exports.printInsertLine = exports.printDeleteLine = exports.MULTILINE_REGEXP = exports.getReceivedString = exports.getExpectedString = exports.getHighlightedString = exports.RECEIVED_COLOR = exports.INVERTED_COLOR = exports.EXPECTED_COLOR = exports.DIM_COLOR = void 0;\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _diffStrings = _interopRequireDefault(require('./diffStrings'));\n\nvar _getAlignedDiffs = _interopRequireDefault(require('./getAlignedDiffs'));\n\nvar _joinAlignedDiffs = require('./joinAlignedDiffs');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst DIM_COLOR = _chalk.default.dim;\nexports.DIM_COLOR = DIM_COLOR;\nconst EXPECTED_COLOR = _chalk.default.green;\nexports.EXPECTED_COLOR = EXPECTED_COLOR;\nconst INVERTED_COLOR = _chalk.default.inverse;\nexports.INVERTED_COLOR = INVERTED_COLOR;\nconst RECEIVED_COLOR = _chalk.default.red;\nexports.RECEIVED_COLOR = RECEIVED_COLOR;\nconst PATCH_COLOR = _chalk.default.yellow; // Given change op and array of diffs, return concatenated string:\n// * include common strings\n// * include change strings which have argument op (inverse highlight)\n// * exclude change strings which have opposite op\n\nconst getHighlightedString = (op, diffs) =>\n  diffs.reduce(\n    (reduced, diff) =>\n      reduced +\n      (diff[0] === _cleanupSemantic.DIFF_EQUAL\n        ? diff[1]\n        : diff[0] === op\n        ? INVERTED_COLOR(diff[1])\n        : ''),\n    ''\n  );\n\nexports.getHighlightedString = getHighlightedString;\n\nconst getExpectedString = diffs =>\n  getHighlightedString(_cleanupSemantic.DIFF_DELETE, diffs);\n\nexports.getExpectedString = getExpectedString;\n\nconst getReceivedString = diffs =>\n  getHighlightedString(_cleanupSemantic.DIFF_INSERT, diffs);\n\nexports.getReceivedString = getReceivedString;\nconst MULTILINE_REGEXP = /\\n/;\nexports.MULTILINE_REGEXP = MULTILINE_REGEXP;\nconst NEWLINE_SYMBOL = '\\u{21B5}'; // downwards arrow with corner leftwards\n\nconst SPACE_SYMBOL = '\\u{00B7}'; // middle dot\n// Instead of inverse highlight which now implies a change,\n// replace common spaces with middle dot at the end of the line.\n\nconst replaceSpacesAtEnd = line =>\n  line.replace(/\\s+$/, spaces => SPACE_SYMBOL.repeat(spaces.length));\n\nconst printDeleteLine = line =>\n  EXPECTED_COLOR(line.length !== 0 ? '- ' + replaceSpacesAtEnd(line) : '-');\n\nexports.printDeleteLine = printDeleteLine;\n\nconst printInsertLine = line =>\n  RECEIVED_COLOR(line.length !== 0 ? '+ ' + replaceSpacesAtEnd(line) : '+'); // Prevent visually ambiguous empty line as the first or the last.\n\nexports.printInsertLine = printInsertLine;\n\nconst printCommonLine = (line, isFirstOrLast = false) =>\n  line.length !== 0\n    ? DIM_COLOR('  ' + replaceSpacesAtEnd(line))\n    : isFirstOrLast\n    ? DIM_COLOR('  ' + NEWLINE_SYMBOL)\n    : '';\n\nexports.printCommonLine = printCommonLine;\n\nconst computeStringDiffs = (expected, received) => {\n  const isMultiline =\n    MULTILINE_REGEXP.test(expected) || MULTILINE_REGEXP.test(received); // getAlignedDiffs assumes that a newline was appended to the strings.\n\n  if (isMultiline) {\n    expected += '\\n';\n    received += '\\n';\n  }\n\n  const diffs = (0, _diffStrings.default)(expected, received);\n  (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function\n\n  return {\n    diffs,\n    isMultiline\n  };\n};\n\nexports.computeStringDiffs = computeStringDiffs;\n\nconst hasCommonDiff = (diffs, isMultiline) => {\n  if (isMultiline) {\n    // Important: Ignore common newline that was appended to multiline strings!\n    const iLast = diffs.length - 1;\n    return diffs.some(\n      (diff, i) =>\n        diff[0] === _cleanupSemantic.DIFF_EQUAL &&\n        (i !== iLast || diff[1] !== '\\n')\n    );\n  }\n\n  return diffs.some(diff => diff[0] === _cleanupSemantic.DIFF_EQUAL);\n};\n\nexports.hasCommonDiff = hasCommonDiff;\n\nconst printAnnotation = options =>\n  EXPECTED_COLOR('- ' + ((options && options.aAnnotation) || 'Expected')) +\n  '\\n' +\n  RECEIVED_COLOR('+ ' + ((options && options.bAnnotation) || 'Received')) +\n  '\\n\\n'; // In GNU diff format, indexes are one-based instead of zero-based.\n\nexports.printAnnotation = printAnnotation;\n\nconst createPatchMark = (aStart, aEnd, bStart, bEnd) =>\n  PATCH_COLOR(\n    `@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`\n  ); // Return formatted diff lines without labels.\n\nexports.createPatchMark = createPatchMark;\n\nconst printMultilineStringDiffs = (diffs, expand) => {\n  const lines = (0, _getAlignedDiffs.default)(diffs);\n  return expand\n    ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(lines)\n    : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(lines);\n};\n\nexports.printMultilineStringDiffs = printMultilineStringDiffs;\nconst MAX_DIFF_STRING_LENGTH = 20000;\n\n// Print specific substring diff for strings only:\n// * if strings are not equal\n// * if neither string is empty\n// * if neither string is too long\n// * if there is a common string after semantic cleanup\nconst getStringDiff = (expected, received, options) => {\n  if (\n    expected === received ||\n    expected.length === 0 ||\n    received.length === 0 ||\n    expected.length > MAX_DIFF_STRING_LENGTH ||\n    received.length > MAX_DIFF_STRING_LENGTH\n  ) {\n    return null;\n  }\n\n  const _computeStringDiffs = computeStringDiffs(expected, received),\n    diffs = _computeStringDiffs.diffs,\n    isMultiline = _computeStringDiffs.isMultiline;\n\n  if (!hasCommonDiff(diffs, isMultiline)) {\n    return null;\n  }\n\n  return isMultiline\n    ? {\n        annotatedDiff:\n          printAnnotation(options) +\n          printMultilineStringDiffs(\n            diffs,\n            options === undefined || options.expand !== false\n          ),\n        isMultiline\n      }\n    : {\n        a: getExpectedString(diffs),\n        b: getReceivedString(diffs),\n        isMultiline\n      };\n};\n\nexports.getStringDiff = getStringDiff;\n"]},"metadata":{},"sourceType":"script"}